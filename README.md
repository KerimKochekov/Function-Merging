# Parameterized Algorithms for Function Merging


Our implementation is built on top of the PLDI 20' artifact of [SalSSA](https://figshare.com/articles/code/pldi20salssa/12089217).

# 1. Directory structure

Root initially has the following files/folders:
- `cpu2017-1_0_5.iso` (SPEC image)
- `myexpcfg.cfg` (SPEC configuration file)
- `compile-spec2017.sh` (script to make SPEC generate `.ll`/`.bc` files to be used by the our/SalSSA's algorithm)
- `llvm-project` holds LLVM source code (including the function merging passes).
- `build-llvm.sh` to build LLVM.
- `build` will hold the built LLVM.
- `run.sh` to feed a benchmark to our implementation and SalSSA's, see below.
- `samples` has some sample files
- `spec2017` directory will hold the extracted and installed SPEC image
- Files generated by SPEC will be stored in folders whose name indicates the the format, `input-bc` or `input-ll` (they are effectively the same; `ll` is human readable, but occupies more space).
- `results` will hold the results of running the pass, including the final binaries and various statistics.

# 2. Depenencies and Benchmarks

## 2.1 GCC, CMake, and Python

```
sudo apt update
sudo apt install -y gcc g++ binutils gcc-multilib g++-multilib cmake python3 python3-pip
python3 -m pip install numpy
python3 -m pip install pandas
python3 -m pip install matplotlib
```

## 2.2 LLVM

We directly use SalSSA's LLVM, which contains their pass `-func-merging`, and add to it our pass `-func-merging-branch-reord`, which itself is based on `-func-merging`. 


```
// When building this LLVM for the first time, in build-llvm.sh, comment line 20 and uncomment line 18
sh build-all.sh 4 // should work with >=8gb ram available
// update .bashrc with the following
export LLVM_DIR=<...>/build
export OPT="<...>/build/bin/opt"
export CLANG="<...>/build/bin/clang"
export CLANGPP="<...>/build/bin/clang++"
export LLLINK="<...>/build/bin/llvm-link"
```

## 2.3 SPEC CPU 2017

#### 2.3.1 Extract and install the SPEC image

Set `EXPER` to project directory (which should contain`cpu2017-1_0_5.iso`).
```
export EXPER=<...>/Function-Merging/
cd $EXPER
mkdir spec2017
mkdir mnt
sudo mount -t iso9660 -o ro,exec,loop cpu2017-1_0_5.iso $EXPER/mnt
$EXPER/mnt/install.sh
```
Here, manually enter `spec2017`'s full path; entering `$EXPER/spec2017` will not work.
```
sudo umount $EXPER/mnt
rm -r mnt
```
Change directory to benchmark folder, then mount the ISO file as below.
```
cd bench
mkdir mnt
sudo mount -t iso9660 -o ro,exec,loop cpu2017-1_0_5.iso $EXPER/mnt
$EXPER/mnt/install.sh
sudo umount $EXPER/mnt
rm -r mnt
```

#### 2.3.2 Generate IRs from SPEC

Note: SPEC2017 has 24 distinct programs, some of them are represented twice as `500.<benchmark_name>_r` and `600.<benchmark_name>_s`; both versions have the same (high-level) source code but are compiled with slightly different options. In such case, we only consider only the 500-instance. We also do not include any benchmarks that are (partially or fully) written in Fortran. This leaves us with 16 programs (9 from "integer" suite, 7 from "floating point" suit): `500.perlbench_r 502.gcc_r 505.mcf_r 508.namd_r 510.parest_r 511.povray_r 519.lbm_r 520.omnetpp_r 523.xalancbmk_r 525.x264_r 526.blender_r 531.deepsjeng_r 538.imagick_r 541.leela_r 544.nab_r 557.xz_r`.

```

./compile-spec2017.sh <LLVM path> <format, either ll or bc> 

./compile-spec2017.sh $LLVM_DIR "ll" 500.perlbench_r 502.gcc_r 505.mcf_r 508.namd_r 510.parest_r 511.povray_r 519.lbm_r 520.omnetpp_r 523.xalancbmk_r 525.x264_r 526.blender_r 531.deepsjeng_r 538.imagick_r 541.leela_r 544.nab_r 557.xz_r
./compile-spec2017.sh $LLVM_DIR "bc" 500.perlbench_r 502.gcc_r 505.mcf_r 508.namd_r 510.parest_r 511.povray_r 519.lbm_r 520.omnetpp_r 523.xalancbmk_r 525.x264_r 526.blender_r 531.deepsjeng_r 538.imagick_r 541.leela_r 544.nab_r 557.xz_r

```

Running, say, the first of these commands will create a folder `input-ll` which will in turn contain a folder for each of the 16 benchmarks. Inside benchmark `X`, there is a file `_main_._all_._files_._linked_.ll` corresponding to the whole program after linking. In addition, there is a folder `units` containing the `.ll`s for every source file in the benchmark. Those will not be used in later steps, but can be taken as small input samples for debugging.


# 3. Running the function merging passes
Take a look at `run.sh` to change the pass options. This will generate output in `results`, including the binaries after merging.
```
// After every update to the pass's code, re-build llvm using build-llvm.sh, but comment line 18, and uncomment line 20.
./build-llvm.sh 4
./run.sh linked <format, either ll or bc> <exploration threshold> <benchmarks>
./run.sh linked ll 10 505.mcf_r 531.deepsjeng_r
```