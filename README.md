# Parameterized Algorithms for Function Merging


Our implementation is built on top of the PLDI 20' artifact of [SalSSA](https://figshare.com/articles/code/pldi20salssa/12089217). One technical difference is that we implement function merging as an out-of-tree pass, instead of integrating it into LLVM.

# 1. Directory structure

- Root initially has the following files/folders:
  - `cpu2017-1_0_5.iso` (SPEC image)
  - `myexpcfg.cfg` (SPEC configuration file)
  - `compile_spec2017.sh` (script to make SPEC generate `.ll` files to be used by the our/SalSSA's algorithm)
  - `config_build_pass.sh` to build the LLVM pass into a shared library. See below for how to use. TODO
  - `run.sh` to feed the benchmark to our implementation and SalSSA's TODO
- `samples` has some sample files
- `spec2017` directory will hold the extracted and installed SPEC image
- Files generated by SPEC will be stored in folders whose name indicates the compilation options, e.g., `-Os` (see 2.3 below).
- `results` will hold the results of running the pass, including the final binaries and various statistics.

# 2. Depenencies and Benchmarks

## 2.1 GCC, CMake, and Python

```
sudo apt update
sudo apt install -y gcc g++ binutils gcc-multilib g++-multilib cmake python3 python3-pip
python3 -m pip install numpy
python3 -m pip install pandas
python3 -m pip install matplotlib
```

## 2.2 LLVM-11

We will use the same LLVM provided in SalSSA's artifact, which already contains SalSSA's function merging pass. We implement our pass for function merging with branch reordering as an out-of-tree pass. First downlaod SalSSA's artifact ([link]((https://figshare.com/articles/code/pldi20salssa/12089217))).
```
export SALSSA=<...>/pldi20ae-final
cd $SALSSA
sh build-all.sh 4 // should work with >=8gb ram available
// update .bashrc with the following
export LLVM_DIR=<...>/pldi20ae-final/build
export OPT="<...>/pldi20ae-final/build/bin/opt"
export CLANG="<...>/pldi20ae-final/build/bin/clang"
export CLANGPP="<...>/pldi20ae-final/build/bin/clang++"
export LLLINK="<...>/pldi20ae-final/build/bin/llvm-link"
```

## 2.3 SPEC CPU 2017

#### 2.3.1 Extract and install the SPEC image

Set `EXPER` to project directory (which should contain`cpu2017-1_0_5.iso`).
```
export EXPER=<...>/Function-Merging/
cd $EXPER
mkdir spec2017
mkdir mnt
sudo mount -t iso9660 -o ro,exec,loop cpu2017-1_0_5.iso $EXPER/mnt
$EXPER/mnt/install.sh
```
Here, manually enter `spec2017`'s full path; entering `$EXPER/spec2017` will not work.
```
sudo umount $EXPER/mnt
rm -r mnt
```
Change directory to benchmark folder, then mount the ISO file as below.
```
cd bench
mkdir mnt
sudo mount -t iso9660 -o ro,exec,loop cpu2017-1_0_5.iso $EXPER/mnt
$EXPER/mnt/install.sh
sudo umount $EXPER/mnt
rm -r mnt
```

#### 2.3.2 Generate IRs from SPEC

Note: SPEC2017 has 24 distinct programs, some of them are represented twice as `500.<benchmark_name>_r` and `600.<benchmark_name>_s`; both versions have the same (high-level) source code but are compiled with slightly different options. In such case, we only consider only the 500-instance. We also do not include any benchmarks that are (partially or fully) written in Fortran. This leaves us with 16 programs (9 from "integer" suite, 7 from "floating point" suit): `500.perlbench_r 502.gcc_r 505.mcf_r 508.namd_r 510.parest_r 511.povray_r 519.lbm_r 520.omnetpp_r 523.xalancbmk_r 525.x264_r 526.blender_r 531.deepsjeng_r 538.imagick_r 541.leela_r 544.nab_r 557.xz_r`.

```

./compile_spec2017.sh <LLVM path> <optimization flags> <format, either ll or bc> 

# -O0
./compile_spec2017.sh $LLVM_DIR "-O0" "ll" 500.perlbench_r 502.gcc_r 505.mcf_r 508.namd_r 510.parest_r 511.povray_r 519.lbm_r 520.omnetpp_r 523.xalancbmk_r 525.x264_r 526.blender_r 531.deepsjeng_r 538.imagick_r 541.leela_r 544.nab_r 557.xz_r
./compile_spec2017.sh $LLVM_DIR "-O0" "bc" 500.perlbench_r 502.gcc_r 505.mcf_r 508.namd_r 510.parest_r 511.povray_r 519.lbm_r 520.omnetpp_r 523.xalancbmk_r 525.x264_r 526.blender_r 531.deepsjeng_r 538.imagick_r 541.leela_r 544.nab_r 557.xz_r

# -Os

./compile_spec2017.sh $LLVM_DIR "-Os" 500.perlbench_r 502.gcc_r 505.mcf_r 508.namd_r 510.parest_r 511.povray_r 519.lbm_r 520.omnetpp_r 523.xalancbmk_r 525.x264_r 526.blender_r 531.deepsjeng_r 538.imagick_r 541.leela_r 544.nab_r 557.xz_r

# -Oz
./compile_spec2017.sh $LLVM_DIR "-Oz" 500.perlbench_r 502.gcc_r 505.mcf_r 508.namd_r 510.parest_r 511.povray_r 519.lbm_r 520.omnetpp_r 523.xalancbmk_r 525.x264_r 526.blender_r 531.deepsjeng_r 538.imagick_r 541.leela_r 544.nab_r 557.xz_r

```

Running, say, the first of these three commands will create a folder `-O0` which will in turn contain a folder for each of the 16 benchmarks. Inside benchmark `X`, there is a directory `linked` containing `X.ll` file corresponding to the whole program after linking, as well as its compiled binaries `X.out`. Our algorithm will process this linked `X.ll`, perform the merging to produce an updated file `X2.ll`, which we then compile into binaries `X2.out` and compare it to the non-merged `X.out`. In addition, there is a folder `units` containing the `.ll`s for every source file in the benchmark. Those will not be used in later steps, but can be taken as small input samples for debugging.


# TODO 3. Function Merging Passes
TODO:
```
./config_build_pass.sh "debug"
// change .so to .dylib on Mac OS
$OPT -load ./function-merging-branch-reord/build/libFunctionMergingBranchReord.so -function-merging-branch-reord  samples/input_for_hello.ll {-o <output>.ll | -disable-output}
$OPT -load ./function-merging-branch-reord/build/libFunctionMergingBranchReord.so -function-merging-branch-reord  samples/input_for_hello.ll -disable-output


./run.sh linked -O0 ll 500.perlbench_r
./run.sh linked -O0 bc 500.perlbench_r
```



The branch alignment merger has been registered as a pass. To compile the pass, suppose LLVM is installed under `/usr/lib/llvm-11` directory, 
```
cd algos
mkdir build
cd build
cmake ../src -DLLVM_ROOT="/usr/lib/llvm-11"
// alternatively, may use '-DLLVM_DIR:PATH' flag
cmake ../src -DLLVM_DIR:PATH="/usr/lib/llvm-11/lib/cmake/llvm"
make
cd ..
```
and three `.so` objects will be generated under `algos/build/lib/` folder.

Set `SALSSA_PATH`, `LCS_PATH`, and `ILP_PATH` to the path of the shared objects, e.g., 
```
export SALSSA_PATH=/home/tshu/Documents/Function-Merging/algos/build/lib/libSALSSA_FM.so
export LCS_PATH=/home/tshu/Documents/Function-Merging/algos/build/lib/libLCS_FM.so
export ILP_PATH=/home/tshu/Documents/Function-Merging/algos/build/lib/libILP_FM.so
```

To generate the IR for a program, use clang-11 to compile
```
clang++-11 -O0 -emit-llvm -S basic.cpp -o basic.ll
```

To run the legacy passes under the `algos` directory, use commands
```
opt-11 --enable-new-pm=false -load $SALSSA_PATH -salssa-fm -S samples/basic.ll
opt-11 --enable-new-pm=false -load $LCS_PATH -lcs-fm -S samples/basic.ll
opt-11 --enable-new-pm=false -load $ILP_PATH -ilp-fm -S samples/basic.ll
```
where `-salssa-fm` calls the original SALSSA merger, `-lcs-fm` calls the merger with optimal branch order given by DP (TODO), and `-ilp-fm` calls the merger with optimal branch order given by ILP solver (TODO).
Add flags `-salssa-fm-verbose`, `-lcs-fm-verbose`, or `-ilp-fm-verbose` to output debug information for corresponding algorithms.
Note that there will be runtime error in the absence of some debug tool packages. Modify all the `dump` to corresponding `errs` statements to resolve runtime errors.

```
opt-11 --enable-new-pm=false -load $SALSSA_PATH -salssa-fm -salssa-fm-verbose -S samples/basic.ll
opt-11 --enable-new-pm=false -load $LCS_PATH -lcs-fm -lcs-fm-verbose -S samples/basic.ll
opt-11 --enable-new-pm=false -load $LCS_PATH -ilp-fm -ilp-fm-verbose -S samples/basic.ll
```

## Compile SPEC with Funciton Merging Passes

To run the optimization pass and link the IRs, use the following script.
```
export EXPER=/home/tshu/Documents/Function-Merging/bench/
export LLVM_DIR=/usr/lib/llvm-11/
export SALSSA_PATH=/home/tshu/Documents/Function-Merging/algos/build/lib/libSALSSA_FM.so
export LCS_PATH=/home/tshu/Documents/Function-Merging/algos/build/lib/libLCS_FM.so
export ILP_PATH=/home/tshu/Documents/Function-Merging/algos/build/lib/libILP_FM.so

cd bench/spec2017
bash compile_opt_link.sh $LLVM_DIR "-O0" $SALSSA_PATH "-salssa-fm" 500.perlbench_r
```

## Clang Suite with Our Function Merging Passes

Under `algos/` folder, use command `sh build-all.sh X` to build the clang suite (replace `X` with the number of threads allowed, preferably 8~16). The clang suite with modified function merging passes will be built under `algos/build/`.

The modified clang suite has different flags that supports four types of function merging actions: no function merging (baseline), FMSA, SALSSA, and LCS. The details of the different flags and built options are specified in `bench/Makefile.lto.default`.

To run the experiments, use shell script `bench/run-all.sh`. The results will be generate under `bench/results/`.
